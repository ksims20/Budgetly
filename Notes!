REACT NATIVE
To start the app: 
npx expo start for the frontend
npx nodemon backend/api.js for the backend

GITHUB
Git add .
Git commit -m “message”
Git push -u origin main

MYSQL
To check if MySql is running: mysql -u root -p

DB NAME:budgetly_db
DB USERNAME: root
DB PASSWORD: k7774363

<!-- NODE.JS
Req.body – Gets data from the front end, whatever the user enters from the front end
Res.json(data) – Sends data back to the Front end
Await – Used as async operation (it takes time to get data from the database) -->

<!-- PRISMA
Initialize: npx prisma init

1.	Change the database provider
2.	Update your .env file
3.	Define your first table
Migrate: prisma migrate dev –name init  (creates the migration folder)
Generate Client: npx prisma generate -->


<!-- After making changes to the file, apply changes using.

npx prisma migrate dev --name add-transaction-type -->


SWAPPED TO SPRINGBOOT FOR THE BACKEND:

Backend rewritten in Java with Spring Boot (v3.5.0) using Maven Daemon (mvnd).

https://start.spring.io/ :

Project: Mavern
Language: Java
Spring Boot: 3.5.0

Project Metadata:

Group: com.budgetly
Artifact: backend
Name: backend
Package: com.budgetly.backend



MAVEN: 

Maven Daemon was installed to Environmental Variables instead of Maven, used mvnd instead of mvd.
Run it in the SpringBoot folder: mvnd spring-boot:run


POSTMAN: 

Used for testing HTTP request


EXPRESS
Makes sure that when data is sent back (in the form of JSON) that Express can read it
app.use(express.json());

EXTRAS
What does your app do?
Your app is a budget tracker, so it needs to store data related to:
•	Income (money coming in)
•	Expenses (money going out)
What kind of information do you need to track?
For each transaction, you’d probably want to know:
•	What the transaction is (e.g., rent, groceries, salary)
•	How much money is involved
•	When the transaction happened
•	Whether it’s income or an expense
•	What category it falls under (food, bills, savings, etc.)
What would this look like in a database?
•	Each transaction needs a unique ID
•	A description of the transaction
•	An amount (money involved)
•	A date when it happened
•	A type (expense or income)

Main Color of app: #5e17eb or #9966CC


EMULATOR:

-Since I didnt run this on an mac machine, I used an android emulator, I could have just used Expo on my Iphone but it was easier this way
-I installed Android Stdudio
-Created a virtual device
-Choose a system image
-From there I could do npm run android (just like you can do npm run ios on Mac)
-Then npx expo start --android



CSS STYLING

- View is like <div>
- Text is like <p>
- Button has properties such as title, and onPress
- TextInput allows the user to type : Has a style, a placeholder, a value, onChangeText, and then you can use secureTextEntry to hide text
- TouchableOpacity, wrapper that make it respod to touch gesture
- StyleSheet defines styles like CSS
- Each page has it's on styling sheet, if you want to use the same styling you can create a new file
- Ex: styles.js, and then in those files import sharedStyles from './styles'; .... <TextInput style={sharedStyles.blahblahblah}>


STATE MANAGEMENT
-useState keeps track of values that can change over time

ANIMATABLE (Ended up not using)
-npx expo install react-native-animatable
-https://github.com/oblador/react-native-animatable

LINEARGRADIENT
-Installed using npx expo install expo-linear-gradient
-When using <LinearGraident> tags you dont need <View>

FONTAWESOME
-Already embedded in Expo no install needed
-If you what to put an icon in a textbox youll have to wrap it in a <view>, otherwise just create it inside <view> or <LinearGradient>











Work on your Dashboard screen

Build UI components in React Native to fetch and display data from your Spring Boot backend

Implement add/update/delete operations if needed

Use libraries you like for styling and animations (Animatable, LinearGradient, FontAwesome, etc.)



Azure & Terraform setup

Once your backend and frontend are communicating well locally, start planning deployment

Use Azure to host your backend (e.g., Azure App Service, Azure Database for MySQL)

Use Terraform to automate provisioning and infrastructure management on Azure

This step might be more involved, so you can do it once your app is stable locally



Add testing

Start with backend tests using JUnit (popular for Java/Spring Boot)

Then move to frontend testing with Jest or React Native Testing Library

Add integration or end-to-end tests as your app matures